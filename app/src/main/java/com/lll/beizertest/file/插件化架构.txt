插件化架构：

一般把一个大的项目分成一个主的apk和一个从的apk。
主apk安装了，从apk放在服务器上，需要的时候下载启动。主要可以减小apk大小，方便用户更新。

插件化实现：
开源的DL插件化实现方式。
插件化要解决的问题：
1.如何解决一个没有在Manifanifest.xml 中注册的Activity 启动报错的问题。
2.

解决没有在Mainfanifest.xml中配置的Activity启动报错：

首先：java的动态代理
1.MVP架构
  P绑定V，P绑定V,每个方法都需要判断V是否是空，采用动态代理，在代理中判断View是否是空
2.数据库懒加载使用静态代理。用到了才去加载。
3.xUtils 源码用到了动态代理。
  setOnClikcListener setOnTouchListener 等

静态代理：
代替你去办理某件事。（去银行办理业务，业务员（代理）帮你办理，这个业务员专门处理这个事，其他人都找她办理，她熟悉，速度快）
业务员和办理业务的其他人都实现指定的某个方法，使用的时候采用替换的方式。传递一个办理的对象，调用其方法。

静态代理如果代理很多功能可能就会产生很多重复的代码。比如:业务员代理你办理很多功能的事情，每次都要重复对
机器进行一些操作。所以提出了动态代理，来处理这个问题。

动态代理：
java本身提供了动态代理的机制。
Proxy 类 以及一个InvocationHandler接口
Proxy.newProxyInstance();调用方法返回一个代理的对象，用来处理调用代理的方法。
方法有三个参数：
第一个参数是代理对象的接口类对应的ClassLoader
第二个参数是一个接口类数组，对应代理类接口的数组(new Class<?>[]{接口类.class})或者对象.getClass().getInterfaces()获取接口数组
第三个参数是InvocationHandler 的实现对象，InvocationHandler 内部处理了代理调用。构造方法要传递一个代理实现类的对象。

动态代理，传递功能的对象，直接调用对象任意的方法，减少重复的步骤和代码。

JDK 动态代理源码分析：
Proxy.newProxyInstance()